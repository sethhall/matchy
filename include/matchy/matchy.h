/* Matchy - Fast Database for IP and Pattern Matching */

#ifndef MATCHY_H
#define MATCHY_H

/* Generated with cbindgen:0.29.0 */

/* WARNING: Auto-generated by cbindgen. Do not edit manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
/* Platform-specific includes for sockaddr and FILE */
#include <stdio.h>
#ifdef _WIN32
    #include <winsock2.h>
    #include <ws2tcpip.h>
#else
    #include <sys/socket.h>
#endif

/* Entry data value union (cbindgen doesn't export unions, so we define it manually) */
typedef union matchy_entry_data_value_u {
    uint32_t pointer;
    const char *utf8_string;
    double double_value;
    const uint8_t *bytes;
    uint16_t uint16;
    uint32_t uint32;
    int32_t int32;
    uint64_t uint64;
    uint8_t uint128[16];
    bool boolean;
    float float_value;
} matchy_entry_data_value_u;


#ifdef __cplusplus
namespace matchy {
#endif  // __cplusplus

/*
 Library major version
 */
#define VERSION_MAJOR 0

/*
 Library minor version
 */
#define VERSION_MINOR 1

/*
 Library patch version
 */
#define VERSION_PATCH 0

/*
 Current version of the AC literal hash format
 */
#define AC_LITERAL_HASH_VERSION 1

/*
 Current version of the literal hash format
 */
#define LITERAL_HASH_VERSION 1

/*
 Current format version (v3: adds AC literal mapping for zero-copy loading)
 */
#define VERSION 3

/*
 Previous format version (v2: adds data section support)
 */
#define VERSION_V2 2

/*
 Previous format version (v1: patterns only, no data)
 */
#define VERSION_V1 1

/*
 Success code
 */
#define MATCHY_SUCCESS 0

/*
 File not found error
 */
#define MATCHY_ERROR_FILE_NOT_FOUND -1

/*
 Invalid format error
 */
#define MATCHY_ERROR_INVALID_FORMAT -2

/*
 Corrupt data error
 */
#define MATCHY_ERROR_CORRUPT_DATA -3

/*
 Out of memory error
 */
#define MATCHY_ERROR_OUT_OF_MEMORY -4

/*
 Invalid parameter error
 */
#define MATCHY_ERROR_INVALID_PARAM -5

/*
 I/O error
 */
#define MATCHY_ERROR_IO -6

/*
 MMDB data type constants (matching libmaxminddb)
 Extended type marker (internal use)
 */
#define MATCHY_DATA_TYPE_EXTENDED 0

/*
 Pointer type for data section references
 */
#define MATCHY_DATA_TYPE_POINTER 1

/*
 UTF-8 encoded string
 */
#define MATCHY_DATA_TYPE_UTF8_STRING 2

/*
 Double precision float (64-bit)
 */
#define MATCHY_DATA_TYPE_DOUBLE 3

/*
 Byte array / binary data
 */
#define MATCHY_DATA_TYPE_BYTES 4

/*
 Unsigned 16-bit integer
 */
#define MATCHY_DATA_TYPE_UINT16 5

/*
 Unsigned 32-bit integer
 */
#define MATCHY_DATA_TYPE_UINT32 6

/*
 Map/dictionary type
 */
#define MATCHY_DATA_TYPE_MAP 7

/*
 Signed 32-bit integer
 */
#define MATCHY_DATA_TYPE_INT32 8

/*
 Unsigned 64-bit integer
 */
#define MATCHY_DATA_TYPE_UINT64 9

/*
 Unsigned 128-bit integer
 */
#define MATCHY_DATA_TYPE_UINT128 10

/*
 Array type
 */
#define MATCHY_DATA_TYPE_ARRAY 11

/*
 Boolean type
 */
#define MATCHY_DATA_TYPE_BOOLEAN 14

/*
 Single precision float (32-bit)
 */
#define MATCHY_DATA_TYPE_FLOAT 15

/*
 Additional error codes for structured data API
 Invalid lookup path specified
 */
#define MATCHY_ERROR_LOOKUP_PATH_INVALID -7

/*
 No data available at the specified path
 */
#define MATCHY_ERROR_NO_DATA -8

/*
 Failed to parse data value
 */
#define MATCHY_ERROR_DATA_PARSE -9

/*
 Opaque database builder handle
 */
typedef struct matchy_builder_t {
  uint8_t _private[0];
} matchy_builder_t;

/*
 Opaque database handle
 */
typedef struct matchy_t {
  uint8_t _private[0];
} matchy_t;

/*
 Query result
 */
typedef struct matchy_result_t {
  /*
   Whether a match was found
   */
  bool found;
  /*
   Network prefix length (for IP results)
   */
  uint8_t prefix_len;
  /*
   Internal pointer to cached DataValue (opaque, for structured data access)
   */
  void *_data_cache;
  /*
   Internal database reference (for entry.db population)
   */
  const struct matchy_t *_db_ref;
} matchy_result_t;

/*
 Entry handle (like MMDB_entry_s)
 */
typedef struct matchy_entry_s {
  /*
   Database handle
   */
  const struct matchy_t *db;
  /*
   Cached data pointer (internal)
   */
  const void *data_ptr;
} matchy_entry_s;

/*
 Entry data structure (like MMDB_entry_data_s)
 */
typedef struct matchy_entry_data_t {
  /*
   Whether data was found
   */
  bool has_data;
  /*
   Data type (one of MATCHY_DATA_TYPE_* constants)
   */
  uint32_t type_;
  /*
   Actual data value
   */
  union matchy_entry_data_value_u value;
  /*
   Size in bytes (for strings, bytes, maps, arrays)
   */
  uint32_t data_size;
  /*
   Internal offset (for debugging)
   */
  uint32_t offset;
} matchy_entry_data_t;

/*
 Entry data list node (like MMDB_entry_data_list_s)
 */
typedef struct matchy_entry_data_list_t {
  /*
   The entry data for this node
   */
  struct matchy_entry_data_t entry_data;
  /*
   Pointer to the next node in the list (NULL if last)
   */
  struct matchy_entry_data_list_t *next;
} matchy_entry_data_list_t;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*
 Create a new database builder

 # Returns
 * Non-null pointer on success
 * NULL on allocation failure

 # Example
 ```c
 matchy_builder_t *builder = matchy_builder_new();
 if (builder == NULL) {
     fprintf(stderr, "Failed to create builder\n");
     return 1;
 }
 ```
 */
struct matchy_builder_t *matchy_builder_new(void);

/*
 Add an entry with associated data (as JSON)

 Automatically detects whether the key is an IP address, CIDR range, or pattern.

 # Parameters
 * `builder` - Builder handle (must not be NULL)
 * `key` - IP address, CIDR, or pattern (null-terminated C string, must not be NULL)
 * `json_data` - Associated data as JSON (null-terminated C string, must not be NULL)

 # Returns
 * MATCHY_SUCCESS (0) on success
 * Error code < 0 on failure

 # Safety
 * `builder` must be a valid pointer from matchy_builder_new
 * `key` must be a valid null-terminated C string
 * `json_data` must be a valid null-terminated C string containing valid JSON

 # Example
 ```c
 matchy_builder_add(builder, "1.2.3.4", "{\"threat_level\": \"high\"}");
 matchy_builder_add(builder, "10.0.0.0/8", "{\"type\": \"internal\"}");
 matchy_builder_add(builder, "*.evil.com", "{\"category\": \"malware\"}");
 ```
 */
int32_t matchy_builder_add(struct matchy_builder_t *builder, const char *key, const char *json_data);

/*
 Set database description

 # Parameters
 * `builder` - Builder handle (must not be NULL)
 * `description` - Description text (null-terminated C string, must not be NULL)

 # Returns
 * MATCHY_SUCCESS (0) on success
 * Error code < 0 on failure

 # Safety
 * `builder` must be a valid pointer from matchy_builder_new
 * `description` must be a valid null-terminated C string
 */
int32_t matchy_builder_set_description(struct matchy_builder_t *builder, const char *description);

/*
 Build and save database to file

 # Parameters
 * `builder` - Builder handle (must not be NULL)
 * `filename` - Path where file should be written (null-terminated C string, must not be NULL)

 # Returns
 * MATCHY_SUCCESS (0) on success
 * Error code < 0 on failure

 # Safety
 * `builder` must be a valid pointer from matchy_builder_new
 * `filename` must be a valid null-terminated C string

 # Example
 ```c
 if (matchy_builder_save(builder, "threats.db") != MATCHY_SUCCESS) {
     fprintf(stderr, "Failed to save database\n");
 }
 ```
 */
int32_t matchy_builder_save(struct matchy_builder_t *builder, const char *filename);

/*
 Build and return database in memory

 # Parameters
 * `builder` - Builder handle (must not be NULL)
 * `buffer` - Pointer to receive the buffer pointer (must not be NULL)
 * `size` - Pointer to receive the buffer size (must not be NULL)

 # Returns
 * MATCHY_SUCCESS (0) on success
 * Error code < 0 on failure

 # Safety
 * `builder` must be a valid pointer from matchy_builder_new
 * `buffer` and `size` must be valid pointers
 * Caller must free the returned buffer with libc::free()

 # Example
 ```c
 uint8_t *buffer = NULL;
 size_t size = 0;
 if (matchy_builder_build(builder, &buffer, &size) == MATCHY_SUCCESS) {
     // Use buffer...
     free(buffer);
 }
 ```
 */
int32_t matchy_builder_build(struct matchy_builder_t *builder, uint8_t **buffer, uintptr_t *size);

/*
 Free builder

 # Parameters
 * `builder` - Builder handle (may be NULL)

 # Safety
 * `builder` must be NULL or a valid pointer from matchy_builder_new
 * Must not be used after calling this function
 * Calling with NULL is safe (no-op)
 */
void matchy_builder_free(struct matchy_builder_t *builder);

/*
 Open database from file (memory-mapped) - SAFE mode

 Opens a database file using memory mapping for optimal performance.
 The file is not loaded into memory - it's accessed on-demand.

 This validates UTF-8 on pattern string reads. Use for untrusted databases.

 # Parameters
 * `filename` - Path to database file (null-terminated C string, must not be NULL)

 # Returns
 * Non-null pointer on success
 * NULL on failure

 # Safety
 * `filename` must be a valid null-terminated C string

 # Example
 ```c
 matchy_t *db = matchy_open("threats.db");
 if (db == NULL) {
     fprintf(stderr, "Failed to open database\n");
     return 1;
 }
 ```
 */
struct matchy_t *matchy_open(const char *filename);

/*
 Open database from file (memory-mapped) - TRUSTED mode

 **SECURITY WARNING**: Only use for databases from trusted sources!
 Skips UTF-8 validation for ~15-20% performance improvement.

 Opens a database file using memory mapping for optimal performance.
 The file is not loaded into memory - it's accessed on-demand.

 # Parameters
 * `filename` - Path to database file (null-terminated C string, must not be NULL)

 # Returns
 * Non-null pointer on success
 * NULL on failure

 # Safety
 * `filename` must be a valid null-terminated C string
 * Database must be from a trusted source (undefined behavior if malicious)

 # Example
 ```c
 // Only for databases you built yourself or trust completely
 matchy_t *db = matchy_open_trusted("my-threats.db");
 if (db == NULL) {
     fprintf(stderr, "Failed to open database\n");
     return 1;
 }
 ```
 */
struct matchy_t *matchy_open_trusted(const char *filename);

/*
 Open database from memory buffer (zero-copy)

 Creates a database handle from a memory buffer. No data is copied.

 # Parameters
 * `buffer` - Pointer to database data (must not be NULL)
 * `size` - Size of buffer in bytes (must be > 0)

 # Returns
 * Non-null pointer on success
 * NULL on failure

 # Safety
 * `buffer` must be valid for the lifetime of the database handle
 * Caller must not modify or free buffer while handle exists
 */
struct matchy_t *matchy_open_buffer(const uint8_t *buffer, uintptr_t size);

/*
 Close database

 Closes the database and frees all associated resources.

 # Parameters
 * `db` - Database handle (may be NULL)

 # Safety
 * `db` must be NULL or a valid pointer from matchy_open
 * Must not be used after calling this function
 * Calling with NULL is safe (no-op)

 # Example
 ```c
 matchy_close(db);
 db = NULL;  // Good practice
 ```
 */
void matchy_close(struct matchy_t *db);

/*
 Unified query interface - automatically detects IP vs pattern

 Queries the database with an IP address or pattern. The function automatically
 detects the query type and uses the appropriate lookup method.

 Returns structured data as DataValue (cached internally).
 Use matchy_result_get_entry() to access structured data,
 or matchy_result_to_json() to convert to JSON.

 # Parameters
 * `db` - Database handle (must not be NULL)
 * `query` - IP address or pattern to search (null-terminated C string, must not be NULL)

 # Returns
 * matchy_result_t with found=true if match found
 * matchy_result_t with found=false if no match
 * Caller must free result with matchy_free_result

 # Safety
 * `db` must be a valid pointer from matchy_open
 * `query` must be a valid null-terminated C string

 # Example
 ```c
 matchy_result_t result = matchy_query(db, "1.2.3.4");
 if (result.found) {
     // Option 1: Get as JSON
     char *json = matchy_result_to_json(&result);
     printf("Found: %s\n", json);
     matchy_free_string(json);

     // Option 2: Access structured data
     matchy_entry_s entry;
     matchy_result_get_entry(&result, &entry);
     // ... use matchy_aget_value()
 }
 matchy_free_result(&result);
 ```
 */
struct matchy_result_t matchy_query(const struct matchy_t *db, const char *query);

/*
 Free query result

 Frees the memory allocated for a query result.

 # Parameters
 * `result` - Pointer to result from matchy_query (must not be NULL)

 # Safety
 * `result` must be a valid pointer to a result from matchy_query
 * Must not be called twice on the same result
 */
void matchy_free_result(struct matchy_result_t *result);

/*
 Free a string returned by matchy

 # Parameters
 * `string` - String pointer returned by matchy (may be NULL)

 # Safety
 * `string` must be NULL or a pointer returned by matchy
 * Must not be called twice on the same pointer
 */
void matchy_free_string(char *string);

/*
 Get library version string

 # Returns
 * Version string (e.g., "0.4.0")
 * Pointer is valid for program lifetime, do not free
 */
const char *matchy_version(void);

/*
 Get database format description

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * Format string ("IP database", "Pattern database", or "Combined IP+Pattern database")
 * Pointer is valid for database lifetime, do not free
 * NULL if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
const char *matchy_format(const struct matchy_t *db);

/*
 Check if database supports IP address lookups

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * true if database contains IP data
 * false if not or if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
bool matchy_has_ip_data(const struct matchy_t *db);

/*
 Check if database supports string lookups (literals or globs)

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * true if database contains literal or glob data
 * false if not or if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
bool matchy_has_string_data(const struct matchy_t *db);

/*
 Check if database supports literal (exact string) lookups

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * true if database contains literal hash data
 * false if not or if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
bool matchy_has_literal_data(const struct matchy_t *db);

/*
 Check if database supports glob pattern lookups

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * true if database contains glob pattern data
 * false if not or if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
bool matchy_has_glob_data(const struct matchy_t *db);

/*
 Check if database supports pattern matching (deprecated)

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * true if database contains pattern data
 * false if not or if db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open

 # Deprecated
 Use matchy_has_literal_data or matchy_has_glob_data instead
 */
bool matchy_has_pattern_data(const struct matchy_t *db);

/*
 Get database metadata as JSON string

 Returns MMDB metadata if available (for IP or combined databases).

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * JSON string containing metadata (caller must free with matchy_free_string)
 * NULL if no metadata available or db is NULL

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
char *matchy_metadata(const struct matchy_t *db);

/*
 Get pattern string by ID

 Returns the pattern string for a given pattern ID.
 Only works for pattern or combined databases.

 # Parameters
 * `db` - Database handle (must not be NULL)
 * `pattern_id` - Pattern ID

 # Returns
 * Pattern string (caller must free with matchy_free_string)
 * NULL if pattern ID not found or db has no patterns

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
char *matchy_get_pattern_string(const struct matchy_t *db, uint32_t pattern_id);

/*
 Get total number of patterns in database

 Returns the number of patterns in the database.
 Only works for pattern or combined databases.

 # Parameters
 * `db` - Database handle (must not be NULL)

 # Returns
 * Number of patterns (0 if no patterns or db is NULL)

 # Safety
 * `db` must be a valid pointer from matchy_open
 */
uintptr_t matchy_pattern_count(const struct matchy_t *db);

/*
 Get entry handle from query result

 This extracts the entry handle which can be used for data navigation.

 # Parameters
 * `result` - Query result (must not be NULL, must have found=true)
 * `entry` - Output entry handle (must not be NULL)

 # Returns
 * MATCHY_SUCCESS on success
 * MATCHY_ERROR_NO_DATA if result not found
 * MATCHY_ERROR_INVALID_PARAM if parameters invalid

 # Safety
 * `result` must be valid result from matchy_query
 * `entry` must be valid pointer to output struct
 * Result must not have been freed

 # Example
 ```c
 matchy_result_t result = matchy_query(db, "8.8.8.8");
 if (result.found) {
     matchy_entry_s entry;
     matchy_result_get_entry(&result, &entry);
 }
 ```
 */
int32_t matchy_result_get_entry(const struct matchy_result_t *result, struct matchy_entry_s *entry);

/*
 Get value using array of strings for path

 Like matchy_get_value but takes an array of strings instead of varargs.

 # Parameters
 * `entry` - Entry handle
 * `entry_data` - Output data
 * `path` - NULL-terminated array of string pointers

 # Returns
 * Same as matchy_get_value

 # Safety
 * Same as matchy_get_value
 * `path` must be NULL-terminated array

 # Example
 ```c
 const char *path[] = {"country", "iso_code", NULL};
 matchy_aget_value(&entry, &data, path);
 ```
 */
int32_t matchy_aget_value(const struct matchy_entry_s *entry, struct matchy_entry_data_t *entry_data, const char *const *path);

/*
 Get full entry data as linked list (tree traversal)

 This function traverses the entire data structure and returns it as
 a flattened linked list. Maps and arrays are expanded recursively.

 # Parameters
 * `entry` - Entry handle
 * `entry_data_list` - Output list pointer

 # Returns
 * MATCHY_SUCCESS on success
 * Error code on failure

 # Safety
 * `entry` must be valid
 * `entry_data_list` must be valid pointer
 * Caller must free result with matchy_free_entry_data_list

 # Example
 ```c
 matchy_entry_data_list_t *list = NULL;
 if (matchy_get_entry_data_list(&entry, &list) == MATCHY_SUCCESS) {
     for (matchy_entry_data_list_t *p = list; p != NULL; p = p->next) {
         // Process p->entry_data
     }
     matchy_free_entry_data_list(list);
 }
 ```
 */
int32_t matchy_get_entry_data_list(const struct matchy_entry_s *entry, struct matchy_entry_data_list_t **entry_data_list);

/*
 Free entry data list

 Frees the linked list returned by matchy_get_entry_data_list.

 # Parameters
 * `list` - List to free (may be NULL)

 # Safety
 * `list` must be from matchy_get_entry_data_list or NULL
 * Must not be freed twice
 */
void matchy_free_entry_data_list(struct matchy_entry_data_list_t *list);

/*
 Convert query result data to JSON string

 This is a convenience function to convert the structured DataValue
 to a JSON string for simple use cases.

 # Parameters
 * `result` - Query result (must not be NULL, must have found=true)

 # Returns
 * JSON string (caller must free with matchy_free_string)
 * NULL if result is NULL, not found, or conversion fails

 # Safety
 * `result` must be a valid pointer to a result from matchy_query
 * Result must not have been freed

 # Example
 ```c
 matchy_result_t result = matchy_query(db, "8.8.8.8");
 if (result.found) {
     char *json = matchy_result_to_json(&result);
     if (json) {
         printf("Data: %s\n", json);
         matchy_free_string(json);
     }
 }
 matchy_free_result(&result);
 ```
 */
char *matchy_result_to_json(const struct matchy_result_t *result);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace matchy
#endif  // __cplusplus

#endif  /* MATCHY_H */
